package main

import (
	"bytes"
	"context"
	"flag"
	"fmt"
	"go/printer"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"strings"

	"github.com/ngicks/und/internal/undgen"
	"golang.org/x/tools/go/packages"
)

var (
	inputPkg    = flag.String("i", "", "input package name. must be rooted or relative path. it's ok to be ./...")
	outFilename = flag.String("o", "", "base name for output file.")
)

func main() {
	cwd, err := os.Getwd()
	if err != nil {
		panic(fmt.Errorf("could not get current working directory: %w", err))
	}

	flag.Parse()

	cfg := &packages.Config{
		Mode: packages.NeedFiles | packages.NeedSyntax | packages.NeedImports |
			packages.NeedDeps | packages.NeedExportFile | packages.NeedTypes |
			packages.NeedSyntax | packages.NeedTypesInfo | packages.NeedModule |
			packages.NeedName, // almost all load bits. We'll reduce option as many as possible.
	}
	pkgs, err := packages.Load(cfg, *inputPkg)
	if err != nil {
		panic(err)
	}

	fmt.Printf("pkgs: %#v\n", pkgs)

	targets, err := undgen.TargetTypes(pkgs)
	if err != nil {
		panic(err)
	}
	fmt.Printf("targets: %#v\n", targets)

	gen, err := undgen.GeneratePlainType(pkgs)
	if err != nil {
		panic(err)
	}

	// TODO: move this print functionality to ../undgen, check each field and trim imports accordingly, tidy imports.
	for k, v := range gen.Pkg {
		for _, genTy := range v {
			pkgName := genTy.PkgName
			if pkgName == "" {
				pkgName = path.Base(k)
			}
			fmt.Printf("pkg path: %s\n\n", genTy.FileName)

			rel, err := filepath.Rel(cwd, genTy.FileName)
			if err != nil {
				panic(err)
			}
			if rel := filepath.ToSlash(rel); strings.HasPrefix(rel, "../") || strings.HasPrefix(rel, "/") {
				panic(fmt.Errorf("generated target file is not under cwd: %s", rel))
			}

			genFilename := suffixFilename(rel, ".undgen_generated")
			fmt.Printf("writing to %q\n", genFilename)
			f, err := os.Create(genFilename)
			if err != nil {
				panic(err)
			}
			func() {
				defer f.Close()

				var buf bytes.Buffer

				fmt.Fprintf(&buf, "package %s\n\n", pkgName)
				fmt.Fprintf(&buf, "import (\n")
				for k, v := range genTy.Imports {
					fmt.Fprintf(&buf, "\t")
					if v != "" {
						fmt.Fprintf(&buf, "%s ", v)
					}
					fmt.Fprintf(&buf, "%q\n", k)
				}
				fmt.Fprintf(&buf, ")\n")

				for _, ty := range genTy.Generated {
					fmt.Fprintf(&buf, "\n")
					fmt.Fprintf(&buf, "//undgen:generated\n")
					printer.Fprint(&buf, ty.Fset, ty.Decl)
					fmt.Fprintf(&buf, "\n\n")
					err = ty.PrintToPlain(&buf)
					if err != nil {
						panic(err)
					}
					fmt.Fprintf(&buf, "\n")
				}

				cmd := exec.CommandContext(context.Background(), "goimports")
				cmd.Stdin = &buf
				var formatted bytes.Buffer
				cmd.Stdout = &formatted
				err := cmd.Run()
				if err != nil {
					panic(err)
				}
				_, err = f.Write([]byte("// " + importPkgComment + "\n"))
				if err != nil {
					panic(err)
				}
				_, err = f.Write(formatted.Bytes())
				if err != nil {
					panic(err)
				}
			}()
		}
	}
}

const (
	// this is merely a place holder.
	generatorPkgName = "github.com/ngicks/und/internal/cmd/undgen"
	importPkgComment = "Code generated by " + generatorPkgName + ". DO NOT EDIT."
)

func suffixFilename(f, suffix string) string {
	ext := filepath.Ext(filepath.Base(f))
	f, _ = strings.CutSuffix(f, ext)
	return f + suffix + ext
}
